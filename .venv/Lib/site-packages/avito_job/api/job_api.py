# coding: utf-8

"""
    Авито.Работа

    API для размещения, редактирования и снятия с публикации вакансии Авито Работа **Авито API для бизнеса предоставляется согласно [Условиям   использования](https://www.avito.ru/legal/pro_tools/public-api).** 

    The version of the OpenAPI document: 1
    Contact: supportautoload@avito.ru
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from uuid import UUID
from avito_job.models.applications_get_by_ids_request import ApplicationsGetByIdsRequest
from avito_job.models.applications_set_is_viewed_request import ApplicationsSetIsViewedRequest
from avito_job.models.applications_webhook_delete200_response import ApplicationsWebhookDelete200Response
from avito_job.models.get_applications_by_ids_result import GetApplicationsByIdsResult
from avito_job.models.get_applications_ids_result import GetApplicationsIdsResult
from avito_job.models.get_dict_by_id200_response_inner import GetDictByID200ResponseInner
from avito_job.models.get_dicts200_response_inner import GetDicts200ResponseInner
from avito_job.models.resume20 import Resume20
from avito_job.models.resume_contacts import ResumeContacts
from avito_job.models.resumes_get200_response import ResumesGet200Response
from avito_job.models.search_vacancy200_response import SearchVacancy200Response
from avito_job.models.set_applicationsis_vewed_result import SetApplicationsisVewedResult
from avito_job.models.vacancies_get_by_ids_body import VacanciesGetByIdsBody
from avito_job.models.vacancy20 import Vacancy20
from avito_job.models.vacancy_archive import VacancyArchive
from avito_job.models.vacancy_auto_renewal import VacancyAutoRenewal
from avito_job.models.vacancy_create import VacancyCreate
from avito_job.models.vacancy_create_result import VacancyCreateResult
from avito_job.models.vacancy_prolongate import VacancyProlongate
from avito_job.models.vacancy_statuses_body import VacancyStatusesBody
from avito_job.models.vacancy_statuses_result_inner import VacancyStatusesResultInner
from avito_job.models.vacancy_update import VacancyUpdate
from avito_job.models.vacancy_v2_create import VacancyV2Create
from avito_job.models.vacancy_v2_create_result import VacancyV2CreateResult
from avito_job.models.webhook_subscribe_request_body import WebhookSubscribeRequestBody
from avito_job.models.webhooks_subscription_result_list import WebhooksSubscriptionResultList

from avito_job.api_client import ApiClient, RequestSerialized
from avito_job.api_response import ApiResponse
from avito_job.rest import RESTResponseType


class JobApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def applications_get_by_ids(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании")] = None,
        applications_get_by_ids_request: Optional[ApplicationsGetByIdsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetApplicationsByIdsResult:
        """Получение списка откликов 

        Получение списка откликов по uuid, полученным по  [подписке на уведомления](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsWebhookPut) (webhook) и через метод  [получение идентификаторов откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetIds) Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param applications_get_by_ids_request:
        :type applications_get_by_ids_request: ApplicationsGetByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_by_ids_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_get_by_ids_request=applications_get_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsByIdsResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_get_by_ids_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании")] = None,
        applications_get_by_ids_request: Optional[ApplicationsGetByIdsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetApplicationsByIdsResult]:
        """Получение списка откликов 

        Получение списка откликов по uuid, полученным по  [подписке на уведомления](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsWebhookPut) (webhook) и через метод  [получение идентификаторов откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetIds) Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param applications_get_by_ids_request:
        :type applications_get_by_ids_request: ApplicationsGetByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_by_ids_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_get_by_ids_request=applications_get_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsByIdsResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_get_by_ids_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании")] = None,
        applications_get_by_ids_request: Optional[ApplicationsGetByIdsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение списка откликов 

        Получение списка откликов по uuid, полученным по  [подписке на уведомления](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsWebhookPut) (webhook) и через метод  [получение идентификаторов откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetIds) Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Сотрудник может получить информацию по откликам для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param applications_get_by_ids_request:
        :type applications_get_by_ids_request: ApplicationsGetByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_by_ids_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_get_by_ids_request=applications_get_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsByIdsResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_get_by_ids_serialize(
        self,
        authorization,
        x_is_employee,
        applications_get_by_ids_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if applications_get_by_ids_request is not None:
            _body_params = applications_get_by_ids_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v1/applications/get_by_ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_get_ids(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        updated_at_from: Annotated[StrictStr, Field(description="Возвращать отклики с датой обновления от указанной даты")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="<p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> ")] = None,
        vacancy_ids: Annotated[Optional[StrictStr], Field(description="Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)")] = None,
        is_viewed: Annotated[Optional[StrictBool], Field(description="Отклик просмотрен")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetApplicationsIdsResult:
        """Получение идентификаторов откликов 

        Возвращает лимитированное количество идентификаторов откликов отсортированных по дате создания  начиная с самых свежих, для последующего получения по ним расширенной информации через метод [получение списка откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetByIds). Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param updated_at_from: Возвращать отклики с датой обновления от указанной даты (required)
        :type updated_at_from: str
        :param x_is_employee: Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param cursor: <p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> 
        :type cursor: str
        :param vacancy_ids: Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)
        :type vacancy_ids: str
        :param is_viewed: Отклик просмотрен
        :type is_viewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_ids_serialize(
            authorization=authorization,
            updated_at_from=updated_at_from,
            x_is_employee=x_is_employee,
            cursor=cursor,
            vacancy_ids=vacancy_ids,
            is_viewed=is_viewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsIdsResult",
            '429': "TooManyRequestsError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_get_ids_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        updated_at_from: Annotated[StrictStr, Field(description="Возвращать отклики с датой обновления от указанной даты")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="<p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> ")] = None,
        vacancy_ids: Annotated[Optional[StrictStr], Field(description="Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)")] = None,
        is_viewed: Annotated[Optional[StrictBool], Field(description="Отклик просмотрен")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetApplicationsIdsResult]:
        """Получение идентификаторов откликов 

        Возвращает лимитированное количество идентификаторов откликов отсортированных по дате создания  начиная с самых свежих, для последующего получения по ним расширенной информации через метод [получение списка откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetByIds). Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param updated_at_from: Возвращать отклики с датой обновления от указанной даты (required)
        :type updated_at_from: str
        :param x_is_employee: Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param cursor: <p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> 
        :type cursor: str
        :param vacancy_ids: Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)
        :type vacancy_ids: str
        :param is_viewed: Отклик просмотрен
        :type is_viewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_ids_serialize(
            authorization=authorization,
            updated_at_from=updated_at_from,
            x_is_employee=x_is_employee,
            cursor=cursor,
            vacancy_ids=vacancy_ids,
            is_viewed=is_viewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsIdsResult",
            '429': "TooManyRequestsError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_get_ids_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        updated_at_from: Annotated[StrictStr, Field(description="Возвращать отклики с датой обновления от указанной даты")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="<p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> ")] = None,
        vacancy_ids: Annotated[Optional[StrictStr], Field(description="Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)")] = None,
        is_viewed: Annotated[Optional[StrictBool], Field(description="Отклик просмотрен")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение идентификаторов откликов 

        Возвращает лимитированное количество идентификаторов откликов отсортированных по дате создания  начиная с самых свежих, для последующего получения по ним расширенной информации через метод [получение списка откликов](https://developers.avito.ru/api-catalog/job/documentation#operation/applicationsGetByIds). Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param updated_at_from: Возвращать отклики с датой обновления от указанной даты (required)
        :type updated_at_from: str
        :param x_is_employee: Сотрудник может получить список его откликов для вакансий которые он разместил в рамках компании
        :type x_is_employee: bool
        :param cursor: <p>Идентификатор последнего отклика из предыдущего запроса</p>  <p>Пример использования параметра:</p>  <p>Получение первой страницы откликов, с датой обновления от 12 июня 2022 года:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12</code></p>  <p><code>[<br>   &nbsp{\"id\": \"62e3e7e542c3d9af3d85205e\",<...>},<br>   &nbsp<...>,<br>   &nbsp{\"id\": \"<strong>623850d1d3819d935dd02702</strong>\",<...>}<br> ]</code></p>  <p>Получение следующей страницы откликов:</p>  <p><code>GET /job/v1/applications/get_ids?updatedAtFrom=2022-06-12&cursor=<strong>623850d1d3819d935dd02702</strong></code></p> 
        :type cursor: str
        :param vacancy_ids: Идентификаторы вакансий. Опциональный фильтр (можно указать одно или несколько значений через запятую)
        :type vacancy_ids: str
        :param is_viewed: Отклик просмотрен
        :type is_viewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_get_ids_serialize(
            authorization=authorization,
            updated_at_from=updated_at_from,
            x_is_employee=x_is_employee,
            cursor=cursor,
            vacancy_ids=vacancy_ids,
            is_viewed=is_viewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetApplicationsIdsResult",
            '429': "TooManyRequestsError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_get_ids_serialize(
        self,
        authorization,
        updated_at_from,
        x_is_employee,
        cursor,
        vacancy_ids,
        is_viewed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if updated_at_from is not None:
            
            _query_params.append(('updatedAtFrom', updated_at_from))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if vacancy_ids is not None:
            
            _query_params.append(('vacancyIds', vacancy_ids))
            
        if is_viewed is not None:
            
            _query_params.append(('is_viewed', is_viewed))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v1/applications/get_ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_set_is_viewed(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Предоставляет возможность менять статус отклика от имени сотрудника")] = None,
        applications_set_is_viewed_request: Optional[ApplicationsSetIsViewedRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SetApplicationsisVewedResult:
        """Изменение статуса отклика 

        Возвращает информацию по откликам и статусу просмотренности отклика, при изменении статуса также статус изменится в Авито Pro.  Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Предоставляет возможность менять статус отклика от имени сотрудника
        :type x_is_employee: bool
        :param applications_set_is_viewed_request:
        :type applications_set_is_viewed_request: ApplicationsSetIsViewedRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_set_is_viewed_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_set_is_viewed_request=applications_set_is_viewed_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetApplicationsisVewedResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_set_is_viewed_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Предоставляет возможность менять статус отклика от имени сотрудника")] = None,
        applications_set_is_viewed_request: Optional[ApplicationsSetIsViewedRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SetApplicationsisVewedResult]:
        """Изменение статуса отклика 

        Возвращает информацию по откликам и статусу просмотренности отклика, при изменении статуса также статус изменится в Авито Pro.  Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Предоставляет возможность менять статус отклика от имени сотрудника
        :type x_is_employee: bool
        :param applications_set_is_viewed_request:
        :type applications_set_is_viewed_request: ApplicationsSetIsViewedRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_set_is_viewed_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_set_is_viewed_request=applications_set_is_viewed_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetApplicationsisVewedResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_set_is_viewed_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Предоставляет возможность менять статус отклика от имени сотрудника")] = None,
        applications_set_is_viewed_request: Optional[ApplicationsSetIsViewedRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Изменение статуса отклика 

        Возвращает информацию по откликам и статусу просмотренности отклика, при изменении статуса также статус изменится в Авито Pro.  Максимальный лимит = 100 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Предоставляет возможность менять статус отклика от имени сотрудника
        :type x_is_employee: bool
        :param applications_set_is_viewed_request:
        :type applications_set_is_viewed_request: ApplicationsSetIsViewedRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_set_is_viewed_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            applications_set_is_viewed_request=applications_set_is_viewed_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetApplicationsisVewedResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_set_is_viewed_serialize(
        self,
        authorization,
        x_is_employee,
        applications_set_is_viewed_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if applications_set_is_viewed_request is not None:
            _body_params = applications_set_is_viewed_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v1/applications/set_is_viewed',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_webhook_delete(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        url: Annotated[Optional[StrictStr], Field(description="URL, на который отправляются уведомления")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationsWebhookDelete200Response:
        """Отключение уведомлений по откликам (webhook) 

        Отписка от уведомлений о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, отписка от вебхука будет для приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param url: URL, на который отправляются уведомления
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_delete_serialize(
            authorization=authorization,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationsWebhookDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_webhook_delete_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        url: Annotated[Optional[StrictStr], Field(description="URL, на который отправляются уведомления")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationsWebhookDelete200Response]:
        """Отключение уведомлений по откликам (webhook) 

        Отписка от уведомлений о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, отписка от вебхука будет для приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param url: URL, на который отправляются уведомления
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_delete_serialize(
            authorization=authorization,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationsWebhookDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_webhook_delete_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        url: Annotated[Optional[StrictStr], Field(description="URL, на который отправляются уведомления")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Отключение уведомлений по откликам (webhook) 

        Отписка от уведомлений о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, отписка от вебхука будет для приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param url: URL, на который отправляются уведомления
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_delete_serialize(
            authorization=authorization,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationsWebhookDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_webhook_delete_serialize(
        self,
        authorization,
        url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if url is not None:
            
            _query_params.append(('url', url))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/job/v1/applications/webhook',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_webhook_get(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscribeRequestBody:
        """Получение информации о подписках (webhook) 

        Получение информации по существующим подпискам на создание и обновление откликов. Будет возвращен самый старый активный вебхук. Если авторизация происходит от имени приложения, будет возвращен вебхук приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_get_serialize(
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_webhook_get_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscribeRequestBody]:
        """Получение информации о подписках (webhook) 

        Получение информации по существующим подпискам на создание и обновление откликов. Будет возвращен самый старый активный вебхук. Если авторизация происходит от имени приложения, будет возвращен вебхук приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_get_serialize(
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_webhook_get_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение информации о подписках (webhook) 

        Получение информации по существующим подпискам на создание и обновление откликов. Будет возвращен самый старый активный вебхук. Если авторизация происходит от имени приложения, будет возвращен вебхук приложения 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_get_serialize(
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_webhook_get_serialize(
        self,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v1/applications/webhook',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_webhook_put(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        webhook_subscribe_request_body: Optional[WebhookSubscribeRequestBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscribeRequestBody:
        """Включение уведомлений по откликам (webhook) 

        Подписка на уведомления о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, вебхук будет привязан к приложению. Исключение:   - изменение сотрудника относящегося к объявлению (employee_id)  Важно:    Проверьте доступность url, при его недоступности из контура Авито webhook не будет создан/перезаписан.   Если url недоступен больше месяца, то он удаляется и на него не придут новые уведомления.   Список адресов с которых идут запросы по url IP 185.89.12.0/22, 146.158.48.0/21, 185.79.237.224/28 и 87.245.204.32/28. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param webhook_subscribe_request_body:
        :type webhook_subscribe_request_body: WebhookSubscribeRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_put_serialize(
            authorization=authorization,
            webhook_subscribe_request_body=webhook_subscribe_request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_webhook_put_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        webhook_subscribe_request_body: Optional[WebhookSubscribeRequestBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscribeRequestBody]:
        """Включение уведомлений по откликам (webhook) 

        Подписка на уведомления о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, вебхук будет привязан к приложению. Исключение:   - изменение сотрудника относящегося к объявлению (employee_id)  Важно:    Проверьте доступность url, при его недоступности из контура Авито webhook не будет создан/перезаписан.   Если url недоступен больше месяца, то он удаляется и на него не придут новые уведомления.   Список адресов с которых идут запросы по url IP 185.89.12.0/22, 146.158.48.0/21, 185.79.237.224/28 и 87.245.204.32/28. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param webhook_subscribe_request_body:
        :type webhook_subscribe_request_body: WebhookSubscribeRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_put_serialize(
            authorization=authorization,
            webhook_subscribe_request_body=webhook_subscribe_request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_webhook_put_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        webhook_subscribe_request_body: Optional[WebhookSubscribeRequestBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Включение уведомлений по откликам (webhook) 

        Подписка на уведомления о создании и обновлении откликов на вакансии. Если авторизация происходит от имени приложения, вебхук будет привязан к приложению. Исключение:   - изменение сотрудника относящегося к объявлению (employee_id)  Важно:    Проверьте доступность url, при его недоступности из контура Авито webhook не будет создан/перезаписан.   Если url недоступен больше месяца, то он удаляется и на него не придут новые уведомления.   Список адресов с которых идут запросы по url IP 185.89.12.0/22, 146.158.48.0/21, 185.79.237.224/28 и 87.245.204.32/28. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param webhook_subscribe_request_body:
        :type webhook_subscribe_request_body: WebhookSubscribeRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhook_put_serialize(
            authorization=authorization,
            webhook_subscribe_request_body=webhook_subscribe_request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscribeRequestBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_webhook_put_serialize(
        self,
        authorization,
        webhook_subscribe_request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter
        if webhook_subscribe_request_body is not None:
            _body_params = webhook_subscribe_request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/job/v1/applications/webhook',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def applications_webhooks_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhooksSubscriptionResultList:
        """Получение списка подписок (webhook) 

        Получение списка активных подписок на создание и обновление откликов в хронологическом порядке от самого старого к самому новому. Если авторизация происходит от имени приложения, будут возвращены вебхуки приложения 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhooks_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhooksSubscriptionResultList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def applications_webhooks_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhooksSubscriptionResultList]:
        """Получение списка подписок (webhook) 

        Получение списка активных подписок на создание и обновление откликов в хронологическом порядке от самого старого к самому новому. Если авторизация происходит от имени приложения, будут возвращены вебхуки приложения 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhooks_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhooksSubscriptionResultList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def applications_webhooks_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение списка подписок (webhook) 

        Получение списка активных подписок на создание и обновление откликов в хронологическом порядке от самого старого к самому новому. Если авторизация происходит от имени приложения, будут возвращены вебхуки приложения 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._applications_webhooks_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhooksSubscriptionResultList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _applications_webhooks_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v1/applications/webhooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_dict_by_id(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        dictionary_id: Annotated[StrictStr, Field(description="Идентификатор словаря")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetDictByID200ResponseInner]:
        """Получение доступных значений списка по ID словаря

        Возвращает доступные значения по имени справочника. Значения с признаком deprecated не могут использоваться при создании и обновлении вакансий.

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param dictionary_id: Идентификатор словаря (required)
        :type dictionary_id: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dict_by_id_serialize(
            authorization=authorization,
            dictionary_id=dictionary_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDictByID200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_dict_by_id_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        dictionary_id: Annotated[StrictStr, Field(description="Идентификатор словаря")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetDictByID200ResponseInner]]:
        """Получение доступных значений списка по ID словаря

        Возвращает доступные значения по имени справочника. Значения с признаком deprecated не могут использоваться при создании и обновлении вакансий.

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param dictionary_id: Идентификатор словаря (required)
        :type dictionary_id: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dict_by_id_serialize(
            authorization=authorization,
            dictionary_id=dictionary_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDictByID200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_dict_by_id_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        dictionary_id: Annotated[StrictStr, Field(description="Идентификатор словаря")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение доступных значений списка по ID словаря

        Возвращает доступные значения по имени справочника. Значения с признаком deprecated не могут использоваться при создании и обновлении вакансий.

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param dictionary_id: Идентификатор словаря (required)
        :type dictionary_id: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dict_by_id_serialize(
            authorization=authorization,
            dictionary_id=dictionary_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDictByID200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_dict_by_id_serialize(
        self,
        authorization,
        dictionary_id,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if dictionary_id is not None:
            _path_params['dictionary_id'] = dictionary_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v2/vacancy/dict/{dictionary_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_dicts(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetDicts200ResponseInner]:
        """Получение списка доступных словарей

        Возвращает все доступные словари (Заменяет существующие списки)

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dicts_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDicts200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_dicts_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetDicts200ResponseInner]]:
        """Получение списка доступных словарей

        Возвращает все доступные словари (Заменяет существующие списки)

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dicts_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDicts200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_dicts_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение списка доступных словарей

        Возвращает все доступные словари (Заменяет существующие списки)

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dicts_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDicts200ResponseInner]",
            '500': "ServiceError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_dicts_serialize(
        self,
        authorization,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v2/vacancy/dict',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_get_contacts(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может получить информацию о резюме приобретенных компанией")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResumeContacts:
        """Доступ к контактным данным соискателя 

        Для получения контактов пользователя необходимо приобрести пакет просмотров в [личном кабинете](https://www.avito.ru/paid-services/contact-packages/cvs). Если резюме было получено из отклика, контакты предоставляются без списания из пакета просмотров. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Сотрудник компании может получить информацию о резюме приобретенных компанией
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_contacts_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumeContacts",
            '400': "ValidatingError",
            '401': "AuthError",
            '402': "PurchasingError",
            '403': "PurchasingError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_get_contacts_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может получить информацию о резюме приобретенных компанией")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResumeContacts]:
        """Доступ к контактным данным соискателя 

        Для получения контактов пользователя необходимо приобрести пакет просмотров в [личном кабинете](https://www.avito.ru/paid-services/contact-packages/cvs). Если резюме было получено из отклика, контакты предоставляются без списания из пакета просмотров. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Сотрудник компании может получить информацию о резюме приобретенных компанией
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_contacts_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumeContacts",
            '400': "ValidatingError",
            '401': "AuthError",
            '402': "PurchasingError",
            '403': "PurchasingError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_get_contacts_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может получить информацию о резюме приобретенных компанией")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Доступ к контактным данным соискателя 

        Для получения контактов пользователя необходимо приобрести пакет просмотров в [личном кабинете](https://www.avito.ru/paid-services/contact-packages/cvs). Если резюме было получено из отклика, контакты предоставляются без списания из пакета просмотров. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Сотрудник компании может получить информацию о резюме приобретенных компанией
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_contacts_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumeContacts",
            '400': "ValidatingError",
            '401': "AuthError",
            '402': "PurchasingError",
            '403': "PurchasingError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_get_contacts_serialize(
        self,
        authorization,
        resume_id,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resume_id is not None:
            _path_params['resume_id'] = resume_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v1/resumes/{resume_id}/contacts/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_get_item(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        photos: Annotated[Optional[StrictBool], Field(description="Признак того, нужно ли отдавать картинки, по умолчанию false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Resume20:
        """Просмотр данных резюме 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type params: str
        :param photos: Признак того, нужно ли отдавать картинки, по умолчанию false
        :type photos: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_item_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            photos=photos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Resume20",
            '400': "BadRequestError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_get_item_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        photos: Annotated[Optional[StrictBool], Field(description="Признак того, нужно ли отдавать картинки, по умолчанию false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Resume20]:
        """Просмотр данных резюме 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type params: str
        :param photos: Признак того, нужно ли отдавать картинки, по умолчанию false
        :type photos: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_item_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            photos=photos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Resume20",
            '400': "BadRequestError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_get_item_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        resume_id: Annotated[StrictInt, Field(description="Идентификатор резюме")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        photos: Annotated[Optional[StrictBool], Field(description="Признак того, нужно ли отдавать картинки, по умолчанию false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Просмотр данных резюме 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param resume_id: Идентификатор резюме (required)
        :type resume_id: int
        :param x_is_employee: Включает привилегии компании для сотрудника, получает доступ к резюме от имени компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type params: str
        :param photos: Признак того, нужно ли отдавать картинки, по умолчанию false
        :type photos: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_get_item_serialize(
            authorization=authorization,
            resume_id=resume_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            photos=photos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Resume20",
            '400': "BadRequestError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_get_item_serialize(
        self,
        authorization,
        resume_id,
        x_is_employee,
        fields,
        params,
        photos,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resume_id is not None:
            _path_params['resume_id'] = resume_id
        # process the query parameters
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if photos is not None:
            
            _query_params.append(('photos', photos))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v2/resumes/{resume_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resumes_get(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 1 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        cursor: Annotated[Optional[StrictInt], Field(description="Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля ответа (можно указать несколько значений через запятую)")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Поисковая фраза")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        specialization: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси ")] = None,
        schedule: Annotated[Optional[StrictStr], Field(description="График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа ")] = None,
        business_trip_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда ")] = None,
        relocation_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен ")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина ")] = None,
        age_min: Annotated[Optional[StrictInt], Field(description="Минимальный возраст (включительно, положительное число от 14 до 99)")] = None,
        age_max: Annotated[Optional[StrictInt], Field(description="Максимальный возраст (включительно, положительное число от 18 до 99)")] = None,
        education_level: Annotated[Optional[StrictStr], Field(description="Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное ")] = None,
        experience_min: Annotated[Optional[StrictInt], Field(description="Минимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        experience_max: Annotated[Optional[StrictInt], Field(description="Максимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        salary_min: Annotated[Optional[StrictInt], Field(description="Минимальный размер заработной платы (включительно, положительное число)")] = None,
        salary_max: Annotated[Optional[StrictInt], Field(description="Максимальный размер заработной платы (включительно, положительное число)")] = None,
        updated_at: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at до текущей даты)")] = None,
        updated_from: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at)")] = None,
        updated_to: Annotated[Optional[datetime], Field(description="Дата последнего обновления (до updated_at)")] = None,
        nationality: Annotated[Optional[StrictInt], Field(description="Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан ")] = None,
        driver_licence: Annotated[Optional[StrictStr], Field(description="Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет ")] = None,
        driver_licence_category: Annotated[Optional[StrictStr], Field(description="Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb ")] = None,
        driving_experience: Annotated[Optional[StrictStr], Field(description="Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет ")] = None,
        own_transport: Annotated[Optional[StrictStr], Field(description="Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед ")] = None,
        medical_book: Annotated[Optional[StrictStr], Field(description="Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResumesGet200Response:
        """Поиск резюме 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param per_page: Количество записей на странице (положительное число от 1 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param cursor: Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)
        :type cursor: int
        :param fields: Поля ответа (можно указать несколько значений через запятую)
        :type fields: str
        :param query: Поисковая фраза
        :type query: str
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param specialization: Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси 
        :type specialization: int
        :param schedule: График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа 
        :type schedule: str
        :param business_trip_readiness: Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда 
        :type business_trip_readiness: str
        :param relocation_readiness: Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен 
        :type relocation_readiness: str
        :param gender: Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина 
        :type gender: str
        :param age_min: Минимальный возраст (включительно, положительное число от 14 до 99)
        :type age_min: int
        :param age_max: Максимальный возраст (включительно, положительное число от 18 до 99)
        :type age_max: int
        :param education_level: Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное 
        :type education_level: str
        :param experience_min: Минимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_min: int
        :param experience_max: Максимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_max: int
        :param salary_min: Минимальный размер заработной платы (включительно, положительное число)
        :type salary_min: int
        :param salary_max: Максимальный размер заработной платы (включительно, положительное число)
        :type salary_max: int
        :param updated_at: Дата последнего обновления (от updated_at до текущей даты)
        :type updated_at: datetime
        :param updated_from: Дата последнего обновления (от updated_at)
        :type updated_from: datetime
        :param updated_to: Дата последнего обновления (до updated_at)
        :type updated_to: datetime
        :param nationality: Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан 
        :type nationality: int
        :param driver_licence: Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет 
        :type driver_licence: str
        :param driver_licence_category: Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb 
        :type driver_licence_category: str
        :param driving_experience: Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет 
        :type driving_experience: str
        :param own_transport: Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед 
        :type own_transport: str
        :param medical_book: Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет 
        :type medical_book: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resumes_get_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            per_page=per_page,
            page=page,
            cursor=cursor,
            fields=fields,
            query=query,
            location=location,
            specialization=specialization,
            schedule=schedule,
            business_trip_readiness=business_trip_readiness,
            relocation_readiness=relocation_readiness,
            gender=gender,
            age_min=age_min,
            age_max=age_max,
            education_level=education_level,
            experience_min=experience_min,
            experience_max=experience_max,
            salary_min=salary_min,
            salary_max=salary_max,
            updated_at=updated_at,
            updated_from=updated_from,
            updated_to=updated_to,
            nationality=nationality,
            driver_licence=driver_licence,
            driver_licence_category=driver_licence_category,
            driving_experience=driving_experience,
            own_transport=own_transport,
            medical_book=medical_book,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumesGet200Response",
            '400': "ValidatingError",
            '401': "AuthError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resumes_get_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 1 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        cursor: Annotated[Optional[StrictInt], Field(description="Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля ответа (можно указать несколько значений через запятую)")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Поисковая фраза")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        specialization: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси ")] = None,
        schedule: Annotated[Optional[StrictStr], Field(description="График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа ")] = None,
        business_trip_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда ")] = None,
        relocation_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен ")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина ")] = None,
        age_min: Annotated[Optional[StrictInt], Field(description="Минимальный возраст (включительно, положительное число от 14 до 99)")] = None,
        age_max: Annotated[Optional[StrictInt], Field(description="Максимальный возраст (включительно, положительное число от 18 до 99)")] = None,
        education_level: Annotated[Optional[StrictStr], Field(description="Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное ")] = None,
        experience_min: Annotated[Optional[StrictInt], Field(description="Минимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        experience_max: Annotated[Optional[StrictInt], Field(description="Максимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        salary_min: Annotated[Optional[StrictInt], Field(description="Минимальный размер заработной платы (включительно, положительное число)")] = None,
        salary_max: Annotated[Optional[StrictInt], Field(description="Максимальный размер заработной платы (включительно, положительное число)")] = None,
        updated_at: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at до текущей даты)")] = None,
        updated_from: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at)")] = None,
        updated_to: Annotated[Optional[datetime], Field(description="Дата последнего обновления (до updated_at)")] = None,
        nationality: Annotated[Optional[StrictInt], Field(description="Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан ")] = None,
        driver_licence: Annotated[Optional[StrictStr], Field(description="Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет ")] = None,
        driver_licence_category: Annotated[Optional[StrictStr], Field(description="Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb ")] = None,
        driving_experience: Annotated[Optional[StrictStr], Field(description="Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет ")] = None,
        own_transport: Annotated[Optional[StrictStr], Field(description="Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед ")] = None,
        medical_book: Annotated[Optional[StrictStr], Field(description="Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResumesGet200Response]:
        """Поиск резюме 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param per_page: Количество записей на странице (положительное число от 1 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param cursor: Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)
        :type cursor: int
        :param fields: Поля ответа (можно указать несколько значений через запятую)
        :type fields: str
        :param query: Поисковая фраза
        :type query: str
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param specialization: Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси 
        :type specialization: int
        :param schedule: График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа 
        :type schedule: str
        :param business_trip_readiness: Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда 
        :type business_trip_readiness: str
        :param relocation_readiness: Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен 
        :type relocation_readiness: str
        :param gender: Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина 
        :type gender: str
        :param age_min: Минимальный возраст (включительно, положительное число от 14 до 99)
        :type age_min: int
        :param age_max: Максимальный возраст (включительно, положительное число от 18 до 99)
        :type age_max: int
        :param education_level: Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное 
        :type education_level: str
        :param experience_min: Минимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_min: int
        :param experience_max: Максимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_max: int
        :param salary_min: Минимальный размер заработной платы (включительно, положительное число)
        :type salary_min: int
        :param salary_max: Максимальный размер заработной платы (включительно, положительное число)
        :type salary_max: int
        :param updated_at: Дата последнего обновления (от updated_at до текущей даты)
        :type updated_at: datetime
        :param updated_from: Дата последнего обновления (от updated_at)
        :type updated_from: datetime
        :param updated_to: Дата последнего обновления (до updated_at)
        :type updated_to: datetime
        :param nationality: Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан 
        :type nationality: int
        :param driver_licence: Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет 
        :type driver_licence: str
        :param driver_licence_category: Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb 
        :type driver_licence_category: str
        :param driving_experience: Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет 
        :type driving_experience: str
        :param own_transport: Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед 
        :type own_transport: str
        :param medical_book: Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет 
        :type medical_book: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resumes_get_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            per_page=per_page,
            page=page,
            cursor=cursor,
            fields=fields,
            query=query,
            location=location,
            specialization=specialization,
            schedule=schedule,
            business_trip_readiness=business_trip_readiness,
            relocation_readiness=relocation_readiness,
            gender=gender,
            age_min=age_min,
            age_max=age_max,
            education_level=education_level,
            experience_min=experience_min,
            experience_max=experience_max,
            salary_min=salary_min,
            salary_max=salary_max,
            updated_at=updated_at,
            updated_from=updated_from,
            updated_to=updated_to,
            nationality=nationality,
            driver_licence=driver_licence,
            driver_licence_category=driver_licence_category,
            driving_experience=driving_experience,
            own_transport=own_transport,
            medical_book=medical_book,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumesGet200Response",
            '400': "ValidatingError",
            '401': "AuthError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resumes_get_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника")] = None,
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 1 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        cursor: Annotated[Optional[StrictInt], Field(description="Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля ответа (можно указать несколько значений через запятую)")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Поисковая фраза")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        specialization: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси ")] = None,
        schedule: Annotated[Optional[StrictStr], Field(description="График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа ")] = None,
        business_trip_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда ")] = None,
        relocation_readiness: Annotated[Optional[StrictStr], Field(description="Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен ")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина ")] = None,
        age_min: Annotated[Optional[StrictInt], Field(description="Минимальный возраст (включительно, положительное число от 14 до 99)")] = None,
        age_max: Annotated[Optional[StrictInt], Field(description="Максимальный возраст (включительно, положительное число от 18 до 99)")] = None,
        education_level: Annotated[Optional[StrictStr], Field(description="Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное ")] = None,
        experience_min: Annotated[Optional[StrictInt], Field(description="Минимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        experience_max: Annotated[Optional[StrictInt], Field(description="Максимальный стаж работы (включительно, положительное число от 0 до 50)")] = None,
        salary_min: Annotated[Optional[StrictInt], Field(description="Минимальный размер заработной платы (включительно, положительное число)")] = None,
        salary_max: Annotated[Optional[StrictInt], Field(description="Максимальный размер заработной платы (включительно, положительное число)")] = None,
        updated_at: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at до текущей даты)")] = None,
        updated_from: Annotated[Optional[datetime], Field(description="Дата последнего обновления (от updated_at)")] = None,
        updated_to: Annotated[Optional[datetime], Field(description="Дата последнего обновления (до updated_at)")] = None,
        nationality: Annotated[Optional[StrictInt], Field(description="Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан ")] = None,
        driver_licence: Annotated[Optional[StrictStr], Field(description="Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет ")] = None,
        driver_licence_category: Annotated[Optional[StrictStr], Field(description="Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb ")] = None,
        driving_experience: Annotated[Optional[StrictStr], Field(description="Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет ")] = None,
        own_transport: Annotated[Optional[StrictStr], Field(description="Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед ")] = None,
        medical_book: Annotated[Optional[StrictStr], Field(description="Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Поиск резюме 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param x_is_employee: Включает привилегии компании для сотрудника
        :type x_is_employee: bool
        :param per_page: Количество записей на странице (положительное число от 1 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param cursor: Курсор поиска (если не указан, будет начат новый поиск и его курсор будет возвращен в ответе)
        :type cursor: int
        :param fields: Поля ответа (можно указать несколько значений через запятую)
        :type fields: str
        :param query: Поисковая фраза
        :type query: str
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param specialization: Идентификатор сферы деятельности (можно указать несколько значений через запятую) <br> Возможные значения: - 10166 - IT, интернет, телеком - 10167 - Медицина, фармацевтика - 10168 - Продажи - 10169 - Страхование - 10170 - Транспорт, логистика - 10171 - Образование, наука - 10172 - Строительство - 10173 - Туризм, рестораны - 10174 - Фитнес, салоны красоты - 10175 - Без опыта, студенты - 10180 - Автомобильный бизнес - 10181 - Бухгалтерия, финансы - 10182 - Высший менеджмент - 10183 - Госслужба, НКО - 10184 - ЖКХ, эксплуатация - 10185 - Искусство, развлечения - 10186 - Консультирование - 10187 - Маркетинг, реклама, PR - 10188 - Охрана, безопасность - 10189 - Управление персоналом - 10190 - Юриспруденция - 10191 - Административная работа - 10192 - Банки, инвестиции - 10193 - Производство, сырьё, с/х - 16844 - Домашний персонал - 2804251 - Курьерская доставка - 2804250 - Такси 
        :type specialization: int
        :param schedule: График работы (можно указать несколько значений через запятую) <br> Возможные значения: - partial-day - Неполный рабочий день - full-day - Полный рабочий день - fly-in-fly-out - Вахтовый метод - flexible - Гибкий график - shift - Сменный график - remote - Удаленная работа 
        :type schedule: str
        :param business_trip_readiness: Готовность к командировкам (можно указать несколько значений через запятую) <br> Возможные значения: - ready - Готов - never - Не готов - sometimes - Иногда 
        :type business_trip_readiness: str
        :param relocation_readiness: Готовность к переезду (можно указать несколько значений через запятую) <br> Возможные значения: - possible - Возможен - never - Невозможен 
        :type relocation_readiness: str
        :param gender: Пол (можно указать несколько значений через запятую) <br> Возможные значения: - female - Женщина - male - Мужчина 
        :type gender: str
        :param age_min: Минимальный возраст (включительно, положительное число от 14 до 99)
        :type age_min: int
        :param age_max: Максимальный возраст (включительно, положительное число от 18 до 99)
        :type age_max: int
        :param education_level: Уровень образования (можно указать несколько значений через запятую) <br> Возможные значения: - higher - Высшее - unfinished-higher - Неоконченное высшее - secondary - Среднее - special-secondary - Среднее специальное 
        :type education_level: str
        :param experience_min: Минимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_min: int
        :param experience_max: Максимальный стаж работы (включительно, положительное число от 0 до 50)
        :type experience_max: int
        :param salary_min: Минимальный размер заработной платы (включительно, положительное число)
        :type salary_min: int
        :param salary_max: Максимальный размер заработной платы (включительно, положительное число)
        :type salary_max: int
        :param updated_at: Дата последнего обновления (от updated_at до текущей даты)
        :type updated_at: datetime
        :param updated_from: Дата последнего обновления (от updated_at)
        :type updated_from: datetime
        :param updated_to: Дата последнего обновления (до updated_at)
        :type updated_to: datetime
        :param nationality: Идентификатор гражданства(можно указать несколько значений через запятую)</br> см. идентификаторы гражданства в [справочнике](https://www.avito.st/s/openapi/catalog_nationality.xml)</br> Распространенные значения: - 15973 - Россия - 15974 - Украина - 15975 - Белоруссия - 15979 - Азербайджан - 15985 - Армения - 16020 - Грузия - 15976 - Казахстан - 16046 - Киргизия - 16082 - Молдавия - 16129 - Таджикистан - 16140 - Узбекистан 
        :type nationality: int
        :param driver_licence: Водительское удостоверение <br> Возможные значения: - yes - Удостоверение есть - no - Удостоверения нет 
        :type driver_licence: str
        :param driver_licence_category: Категория водительского удостоверения (можно указать несколько значений через запятую) <br> Возможные значения:   - a   - b   - be   - c   - ce   - d   - de   - m   - tm   - tb 
        :type driver_licence_category: str
        :param driving_experience: Стаж вождения (можно указать несколько значений через запятую) <br> Возможные значения:   - less-than-three-years - Стаж вождения меньше трех лет   - more-than-three-years - Стаж вождения больше трех лет 
        :type driving_experience: str
        :param own_transport: Свой транспорт (можно указать несколько значений через запятую) <br> Возможные значения:   - no - Нет   - car - Легковое авто   - cargo-car - Грузовое авто   - bike - Мотоцикл   - scooter - Мопед 
        :type own_transport: str
        :param medical_book: Медкнижка <br> Возможные значения:   - yes - Медкнижка есть   - no - Медкнижки нет 
        :type medical_book: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resumes_get_serialize(
            authorization=authorization,
            x_is_employee=x_is_employee,
            per_page=per_page,
            page=page,
            cursor=cursor,
            fields=fields,
            query=query,
            location=location,
            specialization=specialization,
            schedule=schedule,
            business_trip_readiness=business_trip_readiness,
            relocation_readiness=relocation_readiness,
            gender=gender,
            age_min=age_min,
            age_max=age_max,
            education_level=education_level,
            experience_min=experience_min,
            experience_max=experience_max,
            salary_min=salary_min,
            salary_max=salary_max,
            updated_at=updated_at,
            updated_from=updated_from,
            updated_to=updated_to,
            nationality=nationality,
            driver_licence=driver_licence,
            driver_licence_category=driver_licence_category,
            driving_experience=driving_experience,
            own_transport=own_transport,
            medical_book=medical_book,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResumesGet200Response",
            '400': "ValidatingError",
            '401': "AuthError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resumes_get_serialize(
        self,
        authorization,
        x_is_employee,
        per_page,
        page,
        cursor,
        fields,
        query,
        location,
        specialization,
        schedule,
        business_trip_readiness,
        relocation_readiness,
        gender,
        age_min,
        age_max,
        education_level,
        experience_min,
        experience_max,
        salary_min,
        salary_max,
        updated_at,
        updated_from,
        updated_to,
        nationality,
        driver_licence,
        driver_licence_category,
        driving_experience,
        own_transport,
        medical_book,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if location is not None:
            
            _query_params.append(('location', location))
            
        if specialization is not None:
            
            _query_params.append(('specialization', specialization))
            
        if schedule is not None:
            
            _query_params.append(('schedule', schedule))
            
        if business_trip_readiness is not None:
            
            _query_params.append(('business_trip_readiness', business_trip_readiness))
            
        if relocation_readiness is not None:
            
            _query_params.append(('relocation_readiness', relocation_readiness))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age_min is not None:
            
            _query_params.append(('age_min', age_min))
            
        if age_max is not None:
            
            _query_params.append(('age_max', age_max))
            
        if education_level is not None:
            
            _query_params.append(('education_level', education_level))
            
        if experience_min is not None:
            
            _query_params.append(('experience_min', experience_min))
            
        if experience_max is not None:
            
            _query_params.append(('experience_max', experience_max))
            
        if salary_min is not None:
            
            _query_params.append(('salary_min', salary_min))
            
        if salary_max is not None:
            
            _query_params.append(('salary_max', salary_max))
            
        if updated_at is not None:
            if isinstance(updated_at, datetime):
                _query_params.append(
                    (
                        'updated_at',
                        updated_at.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_at', updated_at))
            
        if updated_from is not None:
            if isinstance(updated_from, datetime):
                _query_params.append(
                    (
                        'updated_from',
                        updated_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_from', updated_from))
            
        if updated_to is not None:
            if isinstance(updated_to, datetime):
                _query_params.append(
                    (
                        'updated_to',
                        updated_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updated_to', updated_to))
            
        if nationality is not None:
            
            _query_params.append(('nationality', nationality))
            
        if driver_licence is not None:
            
            _query_params.append(('driver_licence', driver_licence))
            
        if driver_licence_category is not None:
            
            _query_params.append(('driver_licence_category', driver_licence_category))
            
        if driving_experience is not None:
            
            _query_params.append(('driving_experience', driving_experience))
            
        if own_transport is not None:
            
            _query_params.append(('own_transport', own_transport))
            
        if medical_book is not None:
            
            _query_params.append(('medical_book', medical_book))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v1/resumes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_vacancy(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 10 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        business_area: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchVacancy200Response:
        """Поиск вакансий 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param per_page: Количество записей на странице (положительное число от 10 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param business_area: Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> 
        :type business_area: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_vacancy_serialize(
            authorization=authorization,
            per_page=per_page,
            page=page,
            location=location,
            business_area=business_area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchVacancy200Response",
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '403': "SearchVacancy403Response",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_vacancy_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 10 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        business_area: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchVacancy200Response]:
        """Поиск вакансий 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param per_page: Количество записей на странице (положительное число от 10 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param business_area: Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> 
        :type business_area: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_vacancy_serialize(
            authorization=authorization,
            per_page=per_page,
            page=page,
            location=location,
            business_area=business_area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchVacancy200Response",
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '403': "SearchVacancy403Response",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_vacancy_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        per_page: Annotated[Optional[StrictInt], Field(description="Количество записей на странице (положительное число от 10 до 100)")] = None,
        page: Annotated[Optional[StrictInt], Field(description="Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)")] = None,
        location: Annotated[Optional[StrictInt], Field(description="Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). ")] = None,
        business_area: Annotated[Optional[StrictInt], Field(description="Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Поиск вакансий 


        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param per_page: Количество записей на странице (положительное число от 10 до 100)
        :type per_page: int
        :param page: Номер страницы (положительное число больше 0, произведение page на per_page не должно превышать 5000)
        :type page: int
        :param location: Идентификатор региона поиска (можно указать несколько значений через запятую) <br> Метод принимает идентификаторы сущностей Region и City из [справочника](http://autoload.avito.ru/format/Locations.xml). 
        :type location: int
        :param business_area: Идентификатор сферы деятельности  <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> 
        :type business_area: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_vacancy_serialize(
            authorization=authorization,
            per_page=per_page,
            page=page,
            location=location,
            business_area=business_area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchVacancy200Response",
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '403': "SearchVacancy403Response",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_vacancy_serialize(
        self,
        authorization,
        per_page,
        page,
        location,
        business_area,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if location is not None:
            
            _query_params.append(('location', location))
            
        if business_area is not None:
            
            _query_params.append(('business_area', business_area))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v2/vacancies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancies_get_by_ids(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancies_get_by_ids_body: VacanciesGetByIdsBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Vacancy20]:
        """Просмотр данных вакансий 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancies_get_by_ids_body: (required)
        :type vacancies_get_by_ids_body: VacanciesGetByIdsBody
        :param x_is_employee: Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancies_get_by_ids_serialize(
            authorization=authorization,
            vacancies_get_by_ids_body=vacancies_get_by_ids_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Vacancy20]",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '429': "TooManyRequestsError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancies_get_by_ids_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancies_get_by_ids_body: VacanciesGetByIdsBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Vacancy20]]:
        """Просмотр данных вакансий 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancies_get_by_ids_body: (required)
        :type vacancies_get_by_ids_body: VacanciesGetByIdsBody
        :param x_is_employee: Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancies_get_by_ids_serialize(
            authorization=authorization,
            vacancies_get_by_ids_body=vacancies_get_by_ids_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Vacancy20]",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '429': "TooManyRequestsError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancies_get_by_ids_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancies_get_by_ids_body: VacanciesGetByIdsBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Просмотр данных вакансий 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancies_get_by_ids_body: (required)
        :type vacancies_get_by_ids_body: VacanciesGetByIdsBody
        :param x_is_employee: Сотрудник компании получает информацию по вакансиям, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancies_get_by_ids_serialize(
            authorization=authorization,
            vacancies_get_by_ids_body=vacancies_get_by_ids_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Vacancy20]",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '429': "TooManyRequestsError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancies_get_by_ids_serialize(
        self,
        authorization,
        vacancies_get_by_ids_body,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancies_get_by_ids_body is not None:
            _body_params = vacancies_get_by_ids_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v2/vacancies/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_archive(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может остановить публикацию только для своих вакансий")] = None,
        vacancy_archive: Optional[VacancyArchive] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Остановка публикации вакансии

        Снимает с публикации объявление в категории Вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании может остановить публикацию только для своих вакансий
        :type x_is_employee: bool
        :param vacancy_archive:
        :type vacancy_archive: VacancyArchive
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_archive_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            vacancy_archive=vacancy_archive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "StoppingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_archive_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может остановить публикацию только для своих вакансий")] = None,
        vacancy_archive: Optional[VacancyArchive] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Остановка публикации вакансии

        Снимает с публикации объявление в категории Вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании может остановить публикацию только для своих вакансий
        :type x_is_employee: bool
        :param vacancy_archive:
        :type vacancy_archive: VacancyArchive
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_archive_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            vacancy_archive=vacancy_archive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "StoppingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_archive_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может остановить публикацию только для своих вакансий")] = None,
        vacancy_archive: Optional[VacancyArchive] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Остановка публикации вакансии

        Снимает с публикации объявление в категории Вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании может остановить публикацию только для своих вакансий
        :type x_is_employee: bool
        :param vacancy_archive:
        :type vacancy_archive: VacancyArchive
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_archive_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            vacancy_archive=vacancy_archive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "StoppingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_archive_serialize(
        self,
        authorization,
        vacancy_id,
        x_is_employee,
        vacancy_archive,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_id is not None:
            _path_params['vacancy_id'] = vacancy_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_archive is not None:
            _body_params = vacancy_archive


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/job/v1/vacancies/archived/{vacancy_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_auto_renewal(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_auto_renewal: VacancyAutoRenewal,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Автопродление вакансии v2

        Включает или выключает автопродление вакансии. Если вакансия в архиве, то при включении автопродления вакансия будет автоматически поднята из архива. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_auto_renewal: (required)
        :type vacancy_auto_renewal: VacancyAutoRenewal
        :param x_is_employee: Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_auto_renewal_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_auto_renewal=vacancy_auto_renewal,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_auto_renewal_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_auto_renewal: VacancyAutoRenewal,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Автопродление вакансии v2

        Включает или выключает автопродление вакансии. Если вакансия в архиве, то при включении автопродления вакансия будет автоматически поднята из архива. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_auto_renewal: (required)
        :type vacancy_auto_renewal: VacancyAutoRenewal
        :param x_is_employee: Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_auto_renewal_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_auto_renewal=vacancy_auto_renewal,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_auto_renewal_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_auto_renewal: VacancyAutoRenewal,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Автопродление вакансии v2

        Включает или выключает автопродление вакансии. Если вакансия в архиве, то при включении автопродления вакансия будет автоматически поднята из архива. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_auto_renewal: (required)
        :type vacancy_auto_renewal: VacancyAutoRenewal
        :param x_is_employee: Включает привилегии компании для сотрудника, позволяет включать автопродление вакансий принадлежащих сотруднику опубликованных от имени компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_auto_renewal_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_auto_renewal=vacancy_auto_renewal,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ValidatingError",
            '401': "AuthError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_auto_renewal_serialize(
        self,
        authorization,
        vacancy_uuid,
        vacancy_auto_renewal,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_uuid is not None:
            _path_params['vacancy_uuid'] = vacancy_uuid
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_auto_renewal is not None:
            _body_params = vacancy_auto_renewal


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/job/v2/vacancies/{vacancy_uuid}/auto_renewal',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_create(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_create: VacancyCreate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VacancyCreateResult:
        """Публикация вакансии

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_create: (required)
        :type vacancy_create: VacancyCreate
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_serialize(
            authorization=authorization,
            vacancy_create=vacancy_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VacancyCreateResult",
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "CreationForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_create_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_create: VacancyCreate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VacancyCreateResult]:
        """Публикация вакансии

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_create: (required)
        :type vacancy_create: VacancyCreate
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_serialize(
            authorization=authorization,
            vacancy_create=vacancy_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VacancyCreateResult",
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "CreationForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_create_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_create: VacancyCreate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Публикация вакансии

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_create: (required)
        :type vacancy_create: VacancyCreate
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_serialize(
            authorization=authorization,
            vacancy_create=vacancy_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VacancyCreateResult",
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "CreationForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_create_serialize(
        self,
        authorization,
        vacancy_create,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_create is not None:
            _body_params = vacancy_create


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v1/vacancies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_create_v2(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VacancyV2CreateResult:
        """Публикация вакансии v2

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). Для проверки статуса публикации используйте полученный идентификатор в [методе получения статуса](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyGetStatuses). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_v2_serialize(
            authorization=authorization,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_create_v2_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VacancyV2CreateResult]:
        """Публикация вакансии v2

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). Для проверки статуса публикации используйте полученный идентификатор в [методе получения статуса](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyGetStatuses). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_v2_serialize(
            authorization=authorization,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_create_v2_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Публикация вакансии v2

        Для публикации вакансии необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). Для проверки статуса публикации используйте полученный идентификатор в [методе получения статуса](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyGetStatuses). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Вакансия будет публиковаться от имени сотрудника компании, к которой он привязан.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_create_v2_serialize(
            authorization=authorization,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_create_v2_serialize(
        self,
        authorization,
        vacancy_v2_create,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_v2_create is not None:
            _body_params = vacancy_v2_create


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v2/vacancies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_get_item(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Vacancy20:
        """Просмотр данных вакансии 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality
        :type params: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_item_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Vacancy20",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_get_item_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Vacancy20]:
        """Просмотр данных вакансии 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality
        :type params: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_item_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Vacancy20",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_get_item_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии")],
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Просмотр данных вакансии 

        По умолчанию fields и params выводятся все. Если указана только часть полей - остальные поля будут отсутствовать в ответе. Для просмотра данных необходимо быть владельцем вакансии. 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии (required)
        :type vacancy_id: int
        :param x_is_employee: Сотрудник компании получает информацию по вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param fields: Поля основного тела ответа (можно указать несколько значений через запятую). По умолчанию отображаются все поля.
        :type fields: str
        :param params: Дополнительные поля, которые входят в params (можно указать несколько значений через запятую). По умолчанию отображаются все поля. deprecated значения manufacturing_type, industry_type, programs, warehouse_functionality
        :type params: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_item_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            x_is_employee=x_is_employee,
            fields=fields,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Vacancy20",
            '400': "BadRequestError",
            '401': "AuthError",
            '403': "ForbiddenError",
            '404': "NotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_get_item_serialize(
        self,
        authorization,
        vacancy_id,
        x_is_employee,
        fields,
        params,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_id is not None:
            _path_params['vacancy_id'] = vacancy_id
        # process the query parameters
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/job/v2/vacancies/{vacancy_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_get_statuses(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_statuses_body: VacancyStatusesBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VacancyStatusesResultInner]:
        """Получение статуса публикации вакансий V2

        Получение списка статусов процесса публикации и модерации вакансий. В запросе используйте идентификатор, полученный [методе публикации вакансии v2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_statuses_body: (required)
        :type vacancy_statuses_body: VacancyStatusesBody
        :param x_is_employee: Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_statuses_serialize(
            authorization=authorization,
            vacancy_statuses_body=vacancy_statuses_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VacancyStatusesResultInner]",
            '400': "BadRequest",
            '401': "AuthError",
            '403': "ForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_get_statuses_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_statuses_body: VacancyStatusesBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VacancyStatusesResultInner]]:
        """Получение статуса публикации вакансий V2

        Получение списка статусов процесса публикации и модерации вакансий. В запросе используйте идентификатор, полученный [методе публикации вакансии v2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_statuses_body: (required)
        :type vacancy_statuses_body: VacancyStatusesBody
        :param x_is_employee: Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_statuses_serialize(
            authorization=authorization,
            vacancy_statuses_body=vacancy_statuses_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VacancyStatusesResultInner]",
            '400': "BadRequest",
            '401': "AuthError",
            '403': "ForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_get_statuses_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_statuses_body: VacancyStatusesBody,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получение статуса публикации вакансий V2

        Получение списка статусов процесса публикации и модерации вакансий. В запросе используйте идентификатор, полученный [методе публикации вакансии v2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_statuses_body: (required)
        :type vacancy_statuses_body: VacancyStatusesBody
        :param x_is_employee: Сотрудник компании получает информацию о статусе публикации вакансии, которую он опубликовал для компании
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_get_statuses_serialize(
            authorization=authorization,
            vacancy_statuses_body=vacancy_statuses_body,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VacancyStatusesResultInner]",
            '400': "BadRequest",
            '401': "AuthError",
            '403': "ForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_get_statuses_serialize(
        self,
        authorization,
        vacancy_statuses_body,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_statuses_body is not None:
            _body_params = vacancy_statuses_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v2/vacancies/statuses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_prolongate(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_prolongate: VacancyProlongate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может реактивировать только свою вакансию")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Реактивация вакансии

        Реактивирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_prolongate: (required)
        :type vacancy_prolongate: VacancyProlongate
        :param x_is_employee: Сотрудник компании может реактивировать только свою вакансию
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_prolongate_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_prolongate=vacancy_prolongate,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequestShort",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "ActivationForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_prolongate_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_prolongate: VacancyProlongate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может реактивировать только свою вакансию")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Реактивация вакансии

        Реактивирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_prolongate: (required)
        :type vacancy_prolongate: VacancyProlongate
        :param x_is_employee: Сотрудник компании может реактивировать только свою вакансию
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_prolongate_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_prolongate=vacancy_prolongate,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequestShort",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "ActivationForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_prolongate_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_prolongate: VacancyProlongate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может реактивировать только свою вакансию")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Реактивация вакансии

        Реактивирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_prolongate: (required)
        :type vacancy_prolongate: VacancyProlongate
        :param x_is_employee: Сотрудник компании может реактивировать только свою вакансию
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_prolongate_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_prolongate=vacancy_prolongate,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequestShort",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "ActivationForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_prolongate_serialize(
        self,
        authorization,
        vacancy_id,
        vacancy_prolongate,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_id is not None:
            _path_params['vacancy_id'] = vacancy_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_prolongate is not None:
            _body_params = vacancy_prolongate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v1/vacancies/{vacancy_id}/prolongate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_update(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_update: VacancyUpdate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Редактирование вакансии

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_update: (required)
        :type vacancy_update: VacancyUpdate
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_update=vacancy_update,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "EditingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_update_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_update: VacancyUpdate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Редактирование вакансии

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_update: (required)
        :type vacancy_update: VacancyUpdate
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_update=vacancy_update,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "EditingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_update_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_id: Annotated[StrictInt, Field(description="Идентификатор вакансии на сайте")],
        vacancy_update: VacancyUpdate,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Редактирование вакансии

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_id: Идентификатор вакансии на сайте (required)
        :type vacancy_id: int
        :param vacancy_update: (required)
        :type vacancy_update: VacancyUpdate
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_serialize(
            authorization=authorization,
            vacancy_id=vacancy_id,
            vacancy_update=vacancy_update,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "BadRequest",
            '401': "AuthError",
            '402': "PaymentError",
            '403': "EditingForbiddenError",
            '404': "ItemNotFoundError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_update_serialize(
        self,
        authorization,
        vacancy_id,
        vacancy_update,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_id is not None:
            _path_params['vacancy_id'] = vacancy_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_update is not None:
            _body_params = vacancy_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/job/v1/vacancies/{vacancy_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def vacancy_update_v2(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VacancyV2CreateResult:
        """Редактирование вакансии v2

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_v2_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vacancy_update_v2_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VacancyV2CreateResult]:
        """Редактирование вакансии v2

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_v2_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vacancy_update_v2_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Токен для авторизации")],
        vacancy_uuid: Annotated[UUID, Field(description="UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) ) ")],
        vacancy_v2_create: VacancyV2Create,
        x_is_employee: Annotated[Optional[StrictBool], Field(description="Сотрудник компании может редактировать только свои вакансии.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Редактирование вакансии v2

        Редактирует объявление в категории Вакансии. Необходимо приобрести тариф в [личном кабинете](https://www.avito.ru/paid-services/listing-fees). 

        :param authorization: Токен для авторизации (required)
        :type authorization: str
        :param vacancy_uuid: UUID Идентификатор вакансии для V2 ручек (возвращается ручкой [Публикация вакансии V2](https://developers.avito.ru/api-catalog/job/documentation#operation/vacancyCreateV2) )  (required)
        :type vacancy_uuid: str
        :param vacancy_v2_create: (required)
        :type vacancy_v2_create: VacancyV2Create
        :param x_is_employee: Сотрудник компании может редактировать только свои вакансии.
        :type x_is_employee: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vacancy_update_v2_serialize(
            authorization=authorization,
            vacancy_uuid=vacancy_uuid,
            vacancy_v2_create=vacancy_v2_create,
            x_is_employee=x_is_employee,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "VacancyV2CreateResult",
            '400': "BadRequestOnVacancy",
            '401': "AuthError",
            '403': "CreationForbiddenError",
            '500': "ServiceError",
            '503': "ServiceUnavailableError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vacancy_update_v2_serialize(
        self,
        authorization,
        vacancy_uuid,
        vacancy_v2_create,
        x_is_employee,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vacancy_uuid is not None:
            _path_params['vacancy_uuid'] = vacancy_uuid
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_is_employee is not None:
            _header_params['X-Is-Employee'] = x_is_employee
        # process the form parameters
        # process the body parameter
        if vacancy_v2_create is not None:
            _body_params = vacancy_v2_create


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationCode', 
            'ClientCredentials'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/job/v2/vacancies/update/{vacancy_uuid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


