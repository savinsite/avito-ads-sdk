# coding: utf-8

"""
    Мессенджер

    API Мессенджера - набор методов для получения списка чатов пользователя на Авито, получения сообщений в чате, отправки сообщения в чат и другие Через API Мессенджера можно организовать интеграцию между мессенджером Авито и сторонней системой в обе стороны  **Авито API для бизнеса предоставляется согласно [Условиям использования](https://www.avito.ru/legal/pro_tools/public-api).** 

    The version of the OpenAPI document: 1
    Contact: supportautoload@avito.ru
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from avito_messenger.models.message_content_call import MessageContentCall
from avito_messenger.models.message_content_image import MessageContentImage
from avito_messenger.models.message_content_item import MessageContentItem
from avito_messenger.models.message_content_link import MessageContentLink
from avito_messenger.models.message_content_location import MessageContentLocation
from avito_messenger.models.message_content_voice import MessageContentVoice
from typing import Optional, Set
from typing_extensions import Self

class MessageContent(BaseModel):
    """
    Для сообщений типов \"appCall\" \"file\" \"video\" возвращается empty object (данные типы не поддерживаются)
    """ # noqa: E501
    call: Optional[MessageContentCall] = None
    flow_id: Optional[StrictStr] = Field(default=None, description="Идентификатор чат-бота, отправившего сообщение, для сообщений типа system")
    image: Optional[MessageContentImage] = None
    item: Optional[MessageContentItem] = None
    link: Optional[MessageContentLink] = None
    location: Optional[MessageContentLocation] = None
    text: Optional[StrictStr] = Field(default=None, description="Текст сообщения, для сообщения типа text")
    voice: Optional[MessageContentVoice] = None
    __properties: ClassVar[List[str]] = ["call", "flow_id", "image", "item", "link", "location", "text", "voice"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MessageContent from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of call
        if self.call:
            _dict['call'] = self.call.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image
        if self.image:
            _dict['image'] = self.image.to_dict()
        # override the default output from pydantic by calling `to_dict()` of item
        if self.item:
            _dict['item'] = self.item.to_dict()
        # override the default output from pydantic by calling `to_dict()` of link
        if self.link:
            _dict['link'] = self.link.to_dict()
        # override the default output from pydantic by calling `to_dict()` of location
        if self.location:
            _dict['location'] = self.location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of voice
        if self.voice:
            _dict['voice'] = self.voice.to_dict()
        # set to None if call (nullable) is None
        # and model_fields_set contains the field
        if self.call is None and "call" in self.model_fields_set:
            _dict['call'] = None

        # set to None if flow_id (nullable) is None
        # and model_fields_set contains the field
        if self.flow_id is None and "flow_id" in self.model_fields_set:
            _dict['flow_id'] = None

        # set to None if image (nullable) is None
        # and model_fields_set contains the field
        if self.image is None and "image" in self.model_fields_set:
            _dict['image'] = None

        # set to None if item (nullable) is None
        # and model_fields_set contains the field
        if self.item is None and "item" in self.model_fields_set:
            _dict['item'] = None

        # set to None if link (nullable) is None
        # and model_fields_set contains the field
        if self.link is None and "link" in self.model_fields_set:
            _dict['link'] = None

        # set to None if location (nullable) is None
        # and model_fields_set contains the field
        if self.location is None and "location" in self.model_fields_set:
            _dict['location'] = None

        # set to None if text (nullable) is None
        # and model_fields_set contains the field
        if self.text is None and "text" in self.model_fields_set:
            _dict['text'] = None

        # set to None if voice (nullable) is None
        # and model_fields_set contains the field
        if self.voice is None and "voice" in self.model_fields_set:
            _dict['voice'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MessageContent from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "call": MessageContentCall.from_dict(obj["call"]) if obj.get("call") is not None else None,
            "flow_id": obj.get("flow_id"),
            "image": MessageContentImage.from_dict(obj["image"]) if obj.get("image") is not None else None,
            "item": MessageContentItem.from_dict(obj["item"]) if obj.get("item") is not None else None,
            "link": MessageContentLink.from_dict(obj["link"]) if obj.get("link") is not None else None,
            "location": MessageContentLocation.from_dict(obj["location"]) if obj.get("location") is not None else None,
            "text": obj.get("text"),
            "voice": MessageContentVoice.from_dict(obj["voice"]) if obj.get("voice") is not None else None
        })
        return _obj


