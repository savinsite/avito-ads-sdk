# coding: utf-8

"""
    Авито.Работа

    API для размещения, редактирования и снятия с публикации вакансии Авито Работа **Авито API для бизнеса предоставляется согласно [Условиям   использования](https://www.avito.ru/legal/pro_tools/public-api).** 

    The version of the OpenAPI document: 1
    Contact: supportautoload@avito.ru
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from avito_job.models.vacancy20_params_coordinates import Vacancy20ParamsCoordinates
from avito_job.models.vacancy20_params_salary import Vacancy20ParamsSalary
from avito_job.models.vacancy20_params_salary_base_range import Vacancy20ParamsSalaryBaseRange
from typing import Optional, Set
from typing_extensions import Self

class Vacancy20Params(BaseModel):
    """
    Блок с параметрами вакансии. Все поля опциональны и выводятся при наличии
    """ # noqa: E501
    address: Optional[StrictStr] = Field(default=None, description="Место работы")
    age_preferences: Optional[List[StrictStr]] = Field(default=None, description="Подходит кандидатам")
    bonuses: Optional[List[StrictStr]] = Field(default=None, description="Бонусы, которые компания предоставляет кандидатам")
    business_area: Optional[StrictStr] = Field(default=None, description="Сфера деятельности компании. <br> Получить актуальный список доступных значений можно из справочника `business_area` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-business-area.xml) объявлен устаревшим и более не будет использоваться.  <br> ")
    change: Optional[List[StrictStr]] = Field(default=None, description="Смены")
    construction_work_type: Optional[List[StrictStr]] = Field(default=None, description="С какими видами строительных или ремонтных работ предстоит столкнуться кандидату")
    coordinates: Optional[Vacancy20ParamsCoordinates] = None
    cuisine: Optional[List[StrictStr]] = Field(default=None, description="Блюда какой кухни предстоит готовить кандидату")
    delivery_method: Optional[List[StrictStr]] = Field(default=None, description="Способ доставки")
    driving_experience: Optional[StrictStr] = Field(default=None, description="Стаж вождения")
    driving_license_category: Optional[List[StrictStr]] = Field(default=None, description="Категория прав")
    eatery_type: Optional[List[StrictStr]] = Field(default=None, description="Формат заведения общепита в котором предстоит работать кандидату")
    experience: Optional[StrictStr] = Field(default=None, description="Требуемый опыт работы")
    facility_type: Optional[List[StrictStr]] = Field(default=None, description="Тип склада или производственной линии на которой предстоит работать кандидату")
    food_production_shop_type: Optional[List[StrictStr]] = Field(default=None, description="В каком цеху по приготовлению пищи предстоит работать кандидату")
    is_company_car: Optional[StrictStr] = Field(default=None, description="Предоставляет ли компания машину")
    medical_book: Optional[StrictStr] = Field(default=None, description="Требуется ли медкнижка и кем она оформляется при приеме на работу")
    paid_period: Optional[StrictStr] = Field(default=None, description="Оплачиваемый период")
    payout_frequency: Optional[StrictStr] = Field(default=None, description="Частота выплат")
    piecework_flag: Optional[StrictStr] = Field(default=None, description="Сдельная оплата. На самом деле это bool поле. Но из-за ограничений платформы выводим как есть. Т.е. если поле присутствует, значит piecework_flag = true иначе = false")
    profession: Optional[StrictStr] = Field(default=None, description="Название профессии <br> Получить актуальный список доступных значений можно из справочника `profession` через метод [getDictByID](/api-catalog/job/documentation#operation/getDictByID). <br> Статичный [справочник](https://www.avito.st/s/openapi/catalog-profession.xml?v=5) объявлен устаревшим и более не будет использоваться. <br>")
    programs: Optional[List[StrictStr]] = Field(default=None, description="Участие вакансии в программах Авито")
    registration_method: Optional[List[StrictStr]] = Field(default=None, description="Способ оформления")
    retail_equipment_type: Optional[List[StrictStr]] = Field(default=None, description="С каким оборудованием или ПО предстоит работать кандидату")
    retail_shop_type: Optional[List[StrictStr]] = Field(default=None, description="Что продает магазин в котором предстоит работать кандидату")
    salary: Optional[Vacancy20ParamsSalary] = None
    salary_base_bonus: Optional[StrictStr] = Field(default=None, description="Премия")
    salary_base_range: Optional[Vacancy20ParamsSalaryBaseRange] = None
    schedule: Optional[StrictStr] = Field(default=None, description="Режим работы")
    taxes: Optional[StrictStr] = Field(default=None, description="Зарплата указана")
    tools_availability: Optional[StrictStr] = Field(default=None, description="Требуется ли кандидату собственные инструменты для работы")
    where_to_work: Optional[StrictStr] = Field(default=None, description="Где предстоит работать")
    worker_class: Optional[List[StrictStr]] = Field(default=None, description="Предпочтительный разряд кандидата")
    __properties: ClassVar[List[str]] = ["address", "age_preferences", "bonuses", "business_area", "change", "construction_work_type", "coordinates", "cuisine", "delivery_method", "driving_experience", "driving_license_category", "eatery_type", "experience", "facility_type", "food_production_shop_type", "is_company_car", "medical_book", "paid_period", "payout_frequency", "piecework_flag", "profession", "programs", "registration_method", "retail_equipment_type", "retail_shop_type", "salary", "salary_base_bonus", "salary_base_range", "schedule", "taxes", "tools_availability", "where_to_work", "worker_class"]

    @field_validator('age_preferences')
    def age_preferences_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Соискатели старше 45 лет', 'Соискатели от 14 лет', 'Соискатели от 16 лет', 'С нарушениями здоровья', 'Для студентов', 'Для пенсионеров']):
                raise ValueError("each list item must be one of ('Соискатели старше 45 лет', 'Соискатели от 14 лет', 'Соискатели от 16 лет', 'С нарушениями здоровья', 'Для студентов', 'Для пенсионеров')")
        return value

    @field_validator('bonuses')
    def bonuses_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Униформа', 'Проживание', 'Медицинская страховка', 'Питание', 'Оплата бензина', 'Парковка', 'Зоны отдыха', 'Транспорт до работы', 'Скидки в компании', 'Подарки детям на праздники', 'Оплата мобильной связи', 'Обучение', 'Компенсация проезда с работы', 'КАСКО', 'Смартфон', 'Услуги шиномонтажа']):
                raise ValueError("each list item must be one of ('Униформа', 'Проживание', 'Медицинская страховка', 'Питание', 'Оплата бензина', 'Парковка', 'Зоны отдыха', 'Транспорт до работы', 'Скидки в компании', 'Подарки детям на праздники', 'Оплата мобильной связи', 'Обучение', 'Компенсация проезда с работы', 'КАСКО', 'Смартфон', 'Услуги шиномонтажа')")
        return value

    @field_validator('change')
    def change_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['1 / 2', '1 / 3', '2 / 1', '2 / 2', '3 / 3', '3 / 2', '4 / 3', '5 / 2', '4 / 2', '6 / 1', 'Без выходных', 'Утренние', 'Дневные', 'Вечерние', 'Ночные', 'Плавающие выходные', 'Работа по выходным']):
                raise ValueError("each list item must be one of ('1 / 2', '1 / 3', '2 / 1', '2 / 2', '3 / 3', '3 / 2', '4 / 3', '5 / 2', '4 / 2', '6 / 1', 'Без выходных', 'Утренние', 'Дневные', 'Вечерние', 'Ночные', 'Плавающие выходные', 'Работа по выходным')")
        return value

    @field_validator('construction_work_type')
    def construction_work_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Малярные работы', 'Облицовка стен', 'Работы с плиткой', 'Монтаж и установка', 'Отделочные работы', 'Кровельные работы', 'Монтаж и настройка оборудования', 'Сварочные работы', 'Строительство фасадов', 'Формовка материалов', 'Бетонные и каменные работы', 'Ремонтные работы', 'Другие']):
                raise ValueError("each list item must be one of ('Малярные работы', 'Облицовка стен', 'Работы с плиткой', 'Монтаж и установка', 'Отделочные работы', 'Кровельные работы', 'Монтаж и настройка оборудования', 'Сварочные работы', 'Строительство фасадов', 'Формовка материалов', 'Бетонные и каменные работы', 'Ремонтные работы', 'Другие')")
        return value

    @field_validator('cuisine')
    def cuisine_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Русская', 'Европейская', 'Кавказская', 'Итальянская', 'Японская', 'Турецкая', 'Другая']):
                raise ValueError("each list item must be one of ('Русская', 'Европейская', 'Кавказская', 'Итальянская', 'Японская', 'Турецкая', 'Другая')")
        return value

    @field_validator('delivery_method')
    def delivery_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['На автомобиле', 'На велосипеде', 'На самокате', 'Пешком']):
                raise ValueError("each list item must be one of ('На автомобиле', 'На велосипеде', 'На самокате', 'Пешком')")
        return value

    @field_validator('driving_experience')
    def driving_experience_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Нет опыта', 'Меньше года', '1-2 года', '3-5 лет', '6-10 лет', 'Больше 10 лет']):
            raise ValueError("must be one of enum values ('Нет опыта', 'Меньше года', '1-2 года', '3-5 лет', '6-10 лет', 'Больше 10 лет')")
        return value

    @field_validator('driving_license_category')
    def driving_license_category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['A', 'AI', 'AII', 'AIII', 'AIV', 'B', 'B1', 'BE', 'C', 'C1', 'C1E', 'CE', 'D', 'D1', 'D1E', 'DE', 'E', 'F', 'Tm', 'Tb', 'M']):
                raise ValueError("each list item must be one of ('A', 'AI', 'AII', 'AIII', 'AIV', 'B', 'B1', 'BE', 'C', 'C1', 'C1E', 'CE', 'D', 'D1', 'D1E', 'DE', 'E', 'F', 'Tm', 'Tb', 'M')")
        return value

    @field_validator('eatery_type')
    def eatery_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Кафе', 'Бар', 'Фастфуд', 'Ресторан', 'Столовая', 'Пекарня', 'Другой']):
                raise ValueError("each list item must be one of ('Кафе', 'Бар', 'Фастфуд', 'Ресторан', 'Столовая', 'Пекарня', 'Другой')")
        return value

    @field_validator('experience')
    def experience_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Без опыта', 'Более 1 года', 'Более 3 лет', 'Более 5 лет', 'Более 10 лет']):
            raise ValueError("must be one of enum values ('Без опыта', 'Более 1 года', 'Более 3 лет', 'Более 5 лет', 'Более 10 лет')")
        return value

    @field_validator('facility_type')
    def facility_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Производство', 'Логистический центр', 'Склад', 'Другое']):
                raise ValueError("each list item must be one of ('Производство', 'Логистический центр', 'Склад', 'Другое')")
        return value

    @field_validator('food_production_shop_type')
    def food_production_shop_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Холодный', 'Горячий', 'Кондитерский', 'Заготовочный', 'Другой']):
                raise ValueError("each list item must be one of ('Холодный', 'Горячий', 'Кондитерский', 'Заготовочный', 'Другой')")
        return value

    @field_validator('is_company_car')
    def is_company_car_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Да', 'Нет']):
            raise ValueError("must be one of enum values ('Да', 'Нет')")
        return value

    @field_validator('medical_book')
    def medical_book_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Должен оформить кандидат', 'Поможем оформить', 'Не нужна']):
            raise ValueError("must be one of enum values ('Должен оформить кандидат', 'Поможем оформить', 'Не нужна')")
        return value

    @field_validator('paid_period')
    def paid_period_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['в месяц', 'в неделю', 'за смену', 'за час', 'сдельная оплата']):
            raise ValueError("must be one of enum values ('в месяц', 'в неделю', 'за смену', 'за час', 'сдельная оплата')")
        return value

    @field_validator('payout_frequency')
    def payout_frequency_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['почасовая оплата', 'каждый день', 'дважды в месяц', 'раз в неделю', 'три раза в месяц', 'раз в месяц']):
            raise ValueError("must be one of enum values ('почасовая оплата', 'каждый день', 'дважды в месяц', 'раз в неделю', 'три раза в месяц', 'раз в месяц')")
        return value

    @field_validator('piecework_flag')
    def piecework_flag_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Сдельная оплата']):
            raise ValueError("must be one of enum values ('Сдельная оплата')")
        return value

    @field_validator('programs')
    def programs_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Частые выплаты']):
                raise ValueError("each list item must be one of ('Частые выплаты')")
        return value

    @field_validator('registration_method')
    def registration_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Трудовой договор', 'ГПХ с ИП', 'ГПХ с самозанятым', 'ГПХ с физическим лицом']):
                raise ValueError("each list item must be one of ('Трудовой договор', 'ГПХ с ИП', 'ГПХ с самозанятым', 'ГПХ с физическим лицом')")
        return value

    @field_validator('retail_equipment_type')
    def retail_equipment_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Касса и POS-терминалы', 'Программы учёта товаров']):
                raise ValueError("each list item must be one of ('Касса и POS-терминалы', 'Программы учёта товаров')")
        return value

    @field_validator('retail_shop_type')
    def retail_shop_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Гипермаркет или супермаркет', 'Продуктовый', 'Электроника и бытовая техника', 'Одежда и обувь', 'Парфюмерия и косметика', 'Строительство и хозтовары', 'Детские товары', 'Спортивные товары', 'Зоомагазин', 'Аптека', 'Другое']):
                raise ValueError("each list item must be one of ('Гипермаркет или супермаркет', 'Продуктовый', 'Электроника и бытовая техника', 'Одежда и обувь', 'Парфюмерия и косметика', 'Строительство и хозтовары', 'Детские товары', 'Спортивные товары', 'Зоомагазин', 'Аптека', 'Другое')")
        return value

    @field_validator('schedule')
    def schedule_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['5/2', '6/1', 'Вахта', 'Гибкий', 'Сменный', 'Полный день', 'Неполный день', 'Фиксированный', 'Удалённая работа']):
            raise ValueError("must be one of enum values ('5/2', '6/1', 'Вахта', 'Гибкий', 'Сменный', 'Полный день', 'Неполный день', 'Фиксированный', 'Удалённая работа')")
        return value

    @field_validator('taxes')
    def taxes_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['До вычета налогов', 'На руки']):
            raise ValueError("must be one of enum values ('До вычета налогов', 'На руки')")
        return value

    @field_validator('tools_availability')
    def tools_availability_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Нужны свои', 'Предоставляет работодатель']):
            raise ValueError("must be one of enum values ('Нужны свои', 'Предоставляет работодатель')")
        return value

    @field_validator('where_to_work')
    def where_to_work_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['На дому', 'С проживанием', 'Разъездная работа', 'Автозаправочная станция', 'Автосалон', 'Агентство', 'Аптека', 'Аэропорт', 'Банк', 'Вокзал', 'Гостиница', 'Детский сад', 'Кафе или ресторан', 'Кинотеатр', 'Магазин', 'Медицинское учреждение', 'На производстве', 'Ночной клуб', 'Офис', 'Офис продаж', 'Салон красоты', 'Склад', 'Спортклуб', 'Студия', 'Суд', 'Театр', 'Университет', 'Ферма', 'Школа']):
            raise ValueError("must be one of enum values ('На дому', 'С проживанием', 'Разъездная работа', 'Автозаправочная станция', 'Автосалон', 'Агентство', 'Аптека', 'Аэропорт', 'Банк', 'Вокзал', 'Гостиница', 'Детский сад', 'Кафе или ресторан', 'Кинотеатр', 'Магазин', 'Медицинское учреждение', 'На производстве', 'Ночной клуб', 'Офис', 'Офис продаж', 'Салон красоты', 'Склад', 'Спортклуб', 'Студия', 'Суд', 'Театр', 'Университет', 'Ферма', 'Школа')")
        return value

    @field_validator('worker_class')
    def worker_class_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['1', '2', '3', '4', '5 и выше', 'Не требуется']):
                raise ValueError("each list item must be one of ('1', '2', '3', '4', '5 и выше', 'Не требуется')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Vacancy20Params from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of coordinates
        if self.coordinates:
            _dict['coordinates'] = self.coordinates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of salary
        if self.salary:
            _dict['salary'] = self.salary.to_dict()
        # override the default output from pydantic by calling `to_dict()` of salary_base_range
        if self.salary_base_range:
            _dict['salary_base_range'] = self.salary_base_range.to_dict()
        # set to None if address (nullable) is None
        # and model_fields_set contains the field
        if self.address is None and "address" in self.model_fields_set:
            _dict['address'] = None

        # set to None if age_preferences (nullable) is None
        # and model_fields_set contains the field
        if self.age_preferences is None and "age_preferences" in self.model_fields_set:
            _dict['age_preferences'] = None

        # set to None if bonuses (nullable) is None
        # and model_fields_set contains the field
        if self.bonuses is None and "bonuses" in self.model_fields_set:
            _dict['bonuses'] = None

        # set to None if business_area (nullable) is None
        # and model_fields_set contains the field
        if self.business_area is None and "business_area" in self.model_fields_set:
            _dict['business_area'] = None

        # set to None if change (nullable) is None
        # and model_fields_set contains the field
        if self.change is None and "change" in self.model_fields_set:
            _dict['change'] = None

        # set to None if construction_work_type (nullable) is None
        # and model_fields_set contains the field
        if self.construction_work_type is None and "construction_work_type" in self.model_fields_set:
            _dict['construction_work_type'] = None

        # set to None if coordinates (nullable) is None
        # and model_fields_set contains the field
        if self.coordinates is None and "coordinates" in self.model_fields_set:
            _dict['coordinates'] = None

        # set to None if cuisine (nullable) is None
        # and model_fields_set contains the field
        if self.cuisine is None and "cuisine" in self.model_fields_set:
            _dict['cuisine'] = None

        # set to None if delivery_method (nullable) is None
        # and model_fields_set contains the field
        if self.delivery_method is None and "delivery_method" in self.model_fields_set:
            _dict['delivery_method'] = None

        # set to None if driving_experience (nullable) is None
        # and model_fields_set contains the field
        if self.driving_experience is None and "driving_experience" in self.model_fields_set:
            _dict['driving_experience'] = None

        # set to None if driving_license_category (nullable) is None
        # and model_fields_set contains the field
        if self.driving_license_category is None and "driving_license_category" in self.model_fields_set:
            _dict['driving_license_category'] = None

        # set to None if eatery_type (nullable) is None
        # and model_fields_set contains the field
        if self.eatery_type is None and "eatery_type" in self.model_fields_set:
            _dict['eatery_type'] = None

        # set to None if experience (nullable) is None
        # and model_fields_set contains the field
        if self.experience is None and "experience" in self.model_fields_set:
            _dict['experience'] = None

        # set to None if facility_type (nullable) is None
        # and model_fields_set contains the field
        if self.facility_type is None and "facility_type" in self.model_fields_set:
            _dict['facility_type'] = None

        # set to None if food_production_shop_type (nullable) is None
        # and model_fields_set contains the field
        if self.food_production_shop_type is None and "food_production_shop_type" in self.model_fields_set:
            _dict['food_production_shop_type'] = None

        # set to None if is_company_car (nullable) is None
        # and model_fields_set contains the field
        if self.is_company_car is None and "is_company_car" in self.model_fields_set:
            _dict['is_company_car'] = None

        # set to None if medical_book (nullable) is None
        # and model_fields_set contains the field
        if self.medical_book is None and "medical_book" in self.model_fields_set:
            _dict['medical_book'] = None

        # set to None if paid_period (nullable) is None
        # and model_fields_set contains the field
        if self.paid_period is None and "paid_period" in self.model_fields_set:
            _dict['paid_period'] = None

        # set to None if payout_frequency (nullable) is None
        # and model_fields_set contains the field
        if self.payout_frequency is None and "payout_frequency" in self.model_fields_set:
            _dict['payout_frequency'] = None

        # set to None if piecework_flag (nullable) is None
        # and model_fields_set contains the field
        if self.piecework_flag is None and "piecework_flag" in self.model_fields_set:
            _dict['piecework_flag'] = None

        # set to None if profession (nullable) is None
        # and model_fields_set contains the field
        if self.profession is None and "profession" in self.model_fields_set:
            _dict['profession'] = None

        # set to None if programs (nullable) is None
        # and model_fields_set contains the field
        if self.programs is None and "programs" in self.model_fields_set:
            _dict['programs'] = None

        # set to None if registration_method (nullable) is None
        # and model_fields_set contains the field
        if self.registration_method is None and "registration_method" in self.model_fields_set:
            _dict['registration_method'] = None

        # set to None if retail_equipment_type (nullable) is None
        # and model_fields_set contains the field
        if self.retail_equipment_type is None and "retail_equipment_type" in self.model_fields_set:
            _dict['retail_equipment_type'] = None

        # set to None if retail_shop_type (nullable) is None
        # and model_fields_set contains the field
        if self.retail_shop_type is None and "retail_shop_type" in self.model_fields_set:
            _dict['retail_shop_type'] = None

        # set to None if salary (nullable) is None
        # and model_fields_set contains the field
        if self.salary is None and "salary" in self.model_fields_set:
            _dict['salary'] = None

        # set to None if salary_base_bonus (nullable) is None
        # and model_fields_set contains the field
        if self.salary_base_bonus is None and "salary_base_bonus" in self.model_fields_set:
            _dict['salary_base_bonus'] = None

        # set to None if salary_base_range (nullable) is None
        # and model_fields_set contains the field
        if self.salary_base_range is None and "salary_base_range" in self.model_fields_set:
            _dict['salary_base_range'] = None

        # set to None if schedule (nullable) is None
        # and model_fields_set contains the field
        if self.schedule is None and "schedule" in self.model_fields_set:
            _dict['schedule'] = None

        # set to None if taxes (nullable) is None
        # and model_fields_set contains the field
        if self.taxes is None and "taxes" in self.model_fields_set:
            _dict['taxes'] = None

        # set to None if tools_availability (nullable) is None
        # and model_fields_set contains the field
        if self.tools_availability is None and "tools_availability" in self.model_fields_set:
            _dict['tools_availability'] = None

        # set to None if where_to_work (nullable) is None
        # and model_fields_set contains the field
        if self.where_to_work is None and "where_to_work" in self.model_fields_set:
            _dict['where_to_work'] = None

        # set to None if worker_class (nullable) is None
        # and model_fields_set contains the field
        if self.worker_class is None and "worker_class" in self.model_fields_set:
            _dict['worker_class'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Vacancy20Params from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": obj.get("address"),
            "age_preferences": obj.get("age_preferences"),
            "bonuses": obj.get("bonuses"),
            "business_area": obj.get("business_area"),
            "change": obj.get("change"),
            "construction_work_type": obj.get("construction_work_type"),
            "coordinates": Vacancy20ParamsCoordinates.from_dict(obj["coordinates"]) if obj.get("coordinates") is not None else None,
            "cuisine": obj.get("cuisine"),
            "delivery_method": obj.get("delivery_method"),
            "driving_experience": obj.get("driving_experience"),
            "driving_license_category": obj.get("driving_license_category"),
            "eatery_type": obj.get("eatery_type"),
            "experience": obj.get("experience"),
            "facility_type": obj.get("facility_type"),
            "food_production_shop_type": obj.get("food_production_shop_type"),
            "is_company_car": obj.get("is_company_car"),
            "medical_book": obj.get("medical_book"),
            "paid_period": obj.get("paid_period"),
            "payout_frequency": obj.get("payout_frequency"),
            "piecework_flag": obj.get("piecework_flag"),
            "profession": obj.get("profession"),
            "programs": obj.get("programs"),
            "registration_method": obj.get("registration_method"),
            "retail_equipment_type": obj.get("retail_equipment_type"),
            "retail_shop_type": obj.get("retail_shop_type"),
            "salary": Vacancy20ParamsSalary.from_dict(obj["salary"]) if obj.get("salary") is not None else None,
            "salary_base_bonus": obj.get("salary_base_bonus"),
            "salary_base_range": Vacancy20ParamsSalaryBaseRange.from_dict(obj["salary_base_range"]) if obj.get("salary_base_range") is not None else None,
            "schedule": obj.get("schedule"),
            "taxes": obj.get("taxes"),
            "tools_availability": obj.get("tools_availability"),
            "where_to_work": obj.get("where_to_work"),
            "worker_class": obj.get("worker_class")
        })
        return _obj


